/*************************************************************************
	> File Name: is_two_list_insersect.c
	> Created Time: Sun 21 Feb 2016 05:06:36 PM CST
 ************************************************************************/

/**
 *判断两个链表是否相交是这样一个问题：
 *在某些特殊情况的时候，你有两个单向链表头，刚开始是分开的，
 *但是可能到了某个时候,两个链表重合到了一块儿，这样会有一个很大的问题
 *就是说，如果我们删除了其中一个链表，可能会导致另一个链表从某项开始的所有的元素也被删除
 *这样的情况不是我们希望看到的，在这种时候，你需要判断是否链表相交了
 *最简单的方法当然是暴力循环，一个一个查，即判断地一个链表中每个元素是否在第二个链表中
 *这样会导致查询次数为第一个的长度乘以第二个链表的长度，这不是我们所希望的
 *请你设计一个方法，让查询次数降低为第一个链表长度加上第二个链表长度
 **/

 /**
  *思路其实很简单，只需要吧第二个链表的头和第一个链表的尾连起来
  *如果他们相交，必然会使得第二个链表成为一个环，这个问题就转化为了判断是否第二个链表为环的问题
  *查找到第一个链表尾需要遍历第一个链表，然后判断第二个链表是否为环，遍历第二个链表
  *时间复杂度正好为两个链表的长度相加
  **/

typedef struct list{
    int val;
    struct list* next;
}List, *pList;

pList insert(pList* head, pList pos, int val){
    
}

int main(){

    return 0;
}
